<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Promise, async/await</title>
  </head>
  <body>
    <script>
      function loadScript(src, cb) {
        const script = document.createElement("script");
        script.src = src;

        // Используем один колбэк для разных способов с зарезервированным первым аргументом под ошибку
        script.onload = () => cb(null, script);

        // Когда ошибка происходит, то событие срабатывает и мы просто передаем в колбэк ошибку и обрабатываем ее в колбэке
        script.onerror = () =>
          cb(new Error(`The loading script ${script.src} failed`));

        document.body.append(script);
      }

      // Это адская пирамида колбэков только для 5 загружаемых скриптов
      //   Если их будет больше, то это трудно поддерживать
      loadScript(
        "https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.17.21/lodash.min.js",
        step1
      );

      // Create step* funcitons to avoid callback hell
      function step1(error, script) {
        if (error) {
          console.log(error);
        } else {
          console.log(`cool a new ${script.src} loaded`);
          loadScript("src/index.js", step2);
        }
      }
      function step2(error, script) {
        if (error) {
          console.log(error);
        } else {
          console.log(`cool a new ${script.src} loaded`);
          loadScript("src/index.js", step3);
        }
      }
      function step3(error, script) {
        if (error) {
          console.log(error);
        } else {
          console.log(`cool a new ${script.src} loaded`);
          loadScript("src/index.js", step4);
        }
      }

      function step4(error, script) {
        if (error) {
          console.log(error);
        } else {
          console.log(`cool a new ${script.src} loaded`);
        }
      }
      // ...... to show that we can create step* funciton to infinity

      // Итог: Чтобы выполнять асинхронные операции последовательно можно использовать колбэки.

      /* С помощью них можно решать определенные задачи: подождать пока выполниться асинхронная операция и после выполнять уже синхронные; сделать выполнение асинхронных действий последовательными, если внутри колбэка делать следующую асинхронную операцию и так делать цепочки.
       */

      /* Трудности: трудно поддерживать, если нужно выполнить много асинхронных операции; может возникнуть адская пирамида колбэков.
       */
    </script>
  </body>
</html>
