function loadScript(src) {
  return new Promise((res, rej) => {
    const script = document.createElement("script");
    script.src = src;

    script.onload = () => res("Script is loadded successfully");

    script.onerror = () => rej(new Error("Script loading is failure"));

    document.body.append(script);
  });
}

const prom = new Promise(function (res, rej) {
  /**
   * Здесь код выполняется синхронно. Движок доходит до этого места,
   * добавляет в Web API эту макро таску.
   */
  setTimeout(() => {
    console.log("setTimeout1");
    res(1000);
  }, 1);
  /**
   * На собесе было объяснено, что есть минимальная задержка, где-то
   * 2ms, где-то 4ms, и если задержка мешьше чем минимальная, то это
   * все равно, что без задержки.
   *
   * Если выполнять этот код в браузере, то поставив любую задержку,
   * эта макро таска будет выполняться после макро таски без задержки
   * на строке ***.
   *
   * Но если выполнить ее в ноде, то задержка в 1ms будет равносильна
   * тому, что задержки нет вообще и эта таска выполниться перед таской ***.
   *
   * А вот если выставить задержку >=2ms, то там может быть по разному,
   * может эта таска первой выполнться, а может и на строке ***.
   *
   * ГЛАВНАЯ МЫСЛЬ - есть минимальная задержка, и если задержка меньшее
   * минимальной, то макро таски с задержками выполняются первее
   * тасок без задержки
   * */
})
  /**
   * Дойдя до этого места движок добавляет в Web API последующие
   * микро таски .then, НО ВЫПОЛНЯТЬ ИХ ЕЩЕ НЕ НАЧАЛ!!!
   *
   * Движок запланировал выполнить эти микро таски до макро тасок,
   * но после выполнения синхронного кода.
   */
  .then(function (res1) {
    /**
     * Получается, что каждый последующий потребитель результата промиса
     * получает успешно завершенный промис.
     *  */
    console.log("Value in first .then: ", res1);
    return res1 * 2;
  })
  .then(function (res2) {
    console.log("Value in second .then: ", res2);
    return res2 * 2;
  })
  .then(function (res3) {
    console.log("Value in third .then: ", res3);
    return res3 * 2;
  });

/**
 * Здесь код все еще выполняется синхронно. Движок доходит до этого места,
 * добавляет в Web API эту макро таску.
 */
setTimeout(() => {
  // ***
  console.log(
    "Этот код будет выполнен последним. Потому, что это макро таска, которая выполняется всегда после микро тасок - then/catch/finnaly"
  );
});

console.log(prom, "Код, который выполниться первым - ОН СИНХРОННЫЙ!!!!");
